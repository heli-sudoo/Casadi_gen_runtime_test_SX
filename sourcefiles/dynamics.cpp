
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <chrono> // system clock
#include <memory> // smart pointer
#include <thread>

#include "Dyn_FL.h"
#include "Dyn_FL_par.h"
#include "Dyn_FS.h"
#include "Dyn_FS_par.h"
#include "Dyn_BS.h"
#include "Dyn_BS_par.h"
#include "Jacob_F.h"
#include "Jacob_B.h"
#include "Imp_B.h"
#include "Imp_B_par.h"
#include "Imp_F.h"
#include "Imp_F_par.h"
#include "Dyn_FL_sub.h"
#include "Dyn_FL_sub_par.h"
#include "dynamics.h"

using namespace std::this_thread;

int main()
{
    cout << "This code benchmark runtime of dynamics and dynamics partials generated by CasadiGen." << endl;

    u.setZero();
    q << 0, -0.1093, -0.1542, 1.0957, -2.2033, 0.9742, -1.7098;
    qd << 0.9011, 0.2756, 0.7333, 0.0446, 0.0009, 1.3219, 2.7346;
    x << q, qd;

    int mode = 1;
    int foot = 1;
    dt = 0.001;

    sleep_for(microseconds(1000));

    initialization();

    auto start = high_resolution_clock::now();
    int total_trials = 10000;
    for (int i = 0; i < total_trials; i++)
    {
        dynamics(x, u, x_next, y, mode);
        dynamics_par(x, u, fx, fu, gx, gu, mode);
        // resetmap(x, x_next, y, mode);
        resetmap_par(x, Px, Pu, gx, gu, mode);
        footJacobian(x, J, Jd, foot);
    }

    auto stop = high_resolution_clock::now();
    auto duration = duration_cast<microseconds>(stop - start);
    cout << "Runtime : " << duration.count() / total_trials << " microseconds " << endl;
    
    cout << "fx = \n"
         << MatrixXd(fx) << endl;
    cout << "fu = \n"
         << MatrixXd(fu) << endl;
    cout << "gx = \n"
         << MatrixXd(gx) << endl;
    cout << "gu = \n"
         << MatrixXd(gu) << endl;
}

/*!
 * Initialize the sparse matrices with their corresponding sparsity structure.
 * Allocate memories for non-zero elements of sparse matrices.
 * These non-zero elements are updated subsequently when needed.
 */
void initialization()
{
    vector<SpMat *> Mat; // vector of SpMat pointer

    //  /* Initialize inertia matrix H and external forces tau = Su-C(qd)-g(q)
    //     This implementation has been deprecated*/
    // Mat = {&H, &tau};
    // Initialize_Mat(Dyn_FL_sub_sparsity_out, Mat);

    /* Initialize front jacobians */
    Mat = {&J, &Jd};
    initialize_mat(Jacob_F_sparsity_out, Mat);

    /* Initialize dynamics partials */
    Mat = {&fcx, &fcu, &gx, &gu};
    initialize_mat(Dyn_BS_par_sparsity_out, Mat);

    /* Resetmap partial */
    Mat = {&Px, &Pu};
    initialize_mat(Imp_B_par_sparsity_out, Mat);

    /* Build sparse identify matrices*/
    sparseIdentityMat(SpI14);
    sparseIdentityMat(SpI7);
    sparseIdentityMat(SpI4);
}

void initialize_mat(const int_T *f_sparse_out(int_T), vector<SpMat *> &mat)
{
    const int n_out = mat.size();
    size_t idx_out, colidx, idx_nz;
    size_t rows, cols, nnz;

    const casadi_int *spStruct;
    const casadi_int *colOffsets;
    const casadi_int *rowInfo;

    for (idx_out = 0; idx_out < n_out; idx_out++)
    {
        spStruct = f_sparse_out(idx_out);
        rows = spStruct[0];
        cols = spStruct[1];

        colOffsets = spStruct + 2;
        nnz = colOffsets[cols];
        rowInfo = colOffsets + cols + 1;

        idx_nz = 0;
        mat[idx_out]->reserve(nnz);

        for (colidx = 0; colidx < cols; colidx++)
        {
            while (idx_nz < colOffsets[colidx + 1])
            {
                mat[idx_out]->insert(rowInfo[idx_nz], colidx) = 0;
                idx_nz++;
            }
        }
        mat[idx_out]->makeCompressed();
    }
}

void sparseIdentityMat(SpMat &SpI)
{
    for (size_t i = 0; i < SpI.rows(); i++)
    {
        SpI.insert(i, i) = 1;
    }

    SpI.makeCompressed();
}

void dynamics(StateVec &x, ContrlVec &u, StateVec &x_next, OutputVec &y, int mode)
{
    double *arg[2], *res[2], *w = NULL;
    casadi_int *iw = NULL;
    casadi_int sz_arg, sz_res, sz_iw, sz_w;

    arg[0] = x.data();
    arg[1] = u.data();
    res[0] = fc.data();
    res[1] = y.data();

    switch (mode)
    {
    case 2:
    case 4: // flight
        Dyn_FL_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Dyn_FL((const double **)arg, res, iw, w, 1);
        break;
    case 1: // back stance
        Dyn_BS_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Dyn_BS((const double **)arg, res, iw, w, 1);
        break;
    case 3: // front stance
        Dyn_FS_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Dyn_FS((const double **)arg, res, iw, w, 1);
        break;
    }

    /* Descrete-time dynamics*/
    x_next = x + fc * dt;

    if (iw)
        delete[] iw;
    if (w)
        delete[] w;
}

void dynamics_par(StateVec &x, ContrlVec &u, SpMat &fx, SpMat &fu, SpMat &gx, SpMat &gu, int mode)
{
    double *arg[2], *res[4], *w = NULL;
    casadi_int *iw = NULL;
    casadi_int sz_arg, sz_res, sz_iw, sz_w;

    arg[0] = x.data();
    arg[1] = u.data();
    res[0] = fcx.valuePtr();
    res[1] = fcu.valuePtr();
    res[2] = gx.valuePtr();
    res[3] = gu.valuePtr();

    switch (mode)
    {
    case 2:
    case 4: // flight
        Dyn_FL_par_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Dyn_FL_par((const double **)arg, res, iw, w, 1);
        break;
    case 1: // back stance
        Dyn_BS_par_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Dyn_BS_par((const double **)arg, res, iw, w, 1);
        break;
    case 3: // front stance
        Dyn_FS_par_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Dyn_FS_par((const double **)arg, res, iw, w, 1);
        break;
    }

    fx = SpI14 + fcx * dt;
    fu = fcu * dt;

    if (iw)
        delete[] iw;
    if (w)
        delete[] w;
}
/*! 
 * Get resetmap at the end of continuous mode.
 * @ param: mode 1->bs 2->fl 3->fs 4->fl
 */
void resetmap(StateVec &x, StateVec &x_next, OutputVec &y, int mode)
{
    ContrlVec u = ContrlVec::Zero();
    double *arg[2], *res[2], *w = NULL;
    casadi_int *iw = NULL;
    casadi_int sz_arg, sz_res, sz_iw, sz_w;

    arg[0] = x.data();
    arg[1] = u.data();
    res[0] = x_next.data();
    res[1] = y.data();

    switch (mode)
    {
    case 1:
    case 3:
        x_next = x;
        break;
    case 2: //front impact
        Imp_F_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Imp_F((const double **)arg, res, iw, w, 1);
        break;
    case 4: // back impact
        Imp_B_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Imp_B((const double **)arg, res, iw, w, 1);
        break;
    }

    if (iw)
        delete[] iw;
    if (w)
        delete[] w;
}

void resetmap_par(StateVec &x, SpMat &Px, SpMat &Pu, SpMat &gx, SpMat &gu, int mode)
{
    ContrlVec u = ContrlVec::Zero();
    double *arg[2], *res[4], *w = NULL;
    casadi_int *iw = NULL;
    casadi_int sz_arg, sz_res, sz_iw, sz_w;

    arg[0] = x.data();
    arg[1] = u.data();
    res[0] = Px.valuePtr();
    res[1] = Pu.valuePtr();
    res[2] = gx.valuePtr();
    res[3] = gu.valuePtr();

    switch (mode)
    {
    case 1:
    case 3: // smooth transition
        Px = SpI14;
        Pu.setZero();
        gx.setZero();
        gu.setZero();
        break;
    case 2: // front impact
        Imp_F_par_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Imp_F_par((const double **)arg, res, iw, w, 1);
        break;
    case 4: // back impact
        Imp_B_par_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Imp_B_par((const double **)arg, res, iw, w, 1);
        break;
    }
    
    if (iw)
        delete[] iw;
    if (w)
        delete[] w;
}

/*! 
 * Compute front foot and back foot jacobian
 * @ param J: Jacobian
 * @ param Jd: Jacobian derivative
 * @ param foot: 1->front foot  2->back foot  
 */
void footJacobian(StateVec &x, SpMat &J, SpMat &Jd, int foot)
{

    double *arg, *res[2], *w = NULL;
    casadi_int *iw = NULL;
    casadi_int sz_arg, sz_res, sz_iw, sz_w;

    arg = x.data();
    res[0] = J.valuePtr();
    res[1] = Jd.valuePtr();

    if (1 == foot) // front foot
    {
        Jacob_F_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Jacob_F((const double **)arg, res, iw, w, 1);
    }
    else if (2 == foot) // back foot
    {
        Jacob_B_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
        iw = new casadi_int[sz_iw];
        w = new double[sz_w];
        Jacob_B((const double **)arg, res, iw, w, 1);
    }

    if (iw)
        delete[] iw;
    if (w)
        delete[] w;
}

void test()
{
    const int a[5] = {1, 2, 3, 4, 5};
    const char *b = "Hello";
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
}

/*! 
  Old implementation of computing dynamics.
 */
void dynamics_old(StateVec &x, ContrlVec &u, StateVec &x_next, OutputVec &y)
{
    read_dyn_info(x, u, H, tau);
    solver.compute(H);
    auto qd_next = solver.solve(tau);
    qd_next_f = MatrixXd(qd_next);
}

/*!@ brief: Read H and tau. 
 * @ params: H and tau -> Inertia matrix and coriolis (tangential etc) forces*/
void read_dyn_info(StateVec &x, ContrlVec &u, SpMat &H, SpMat &tau)
{
    double *arg[2], *res[2], *w;
    casadi_int *iw;
    casadi_int sz_arg, sz_res, sz_iw, sz_w;
    Dyn_FL_sub_work(&sz_arg, &sz_res, &sz_iw, &sz_w);

    arg[0] = x.data();
    arg[1] = u.data();
    res[0] = H.valuePtr();
    res[1] = tau.valuePtr();
    iw = new casadi_int[sz_iw];
    w = new double[sz_w];

    Dyn_FL_sub((const double **)arg, res, iw, w, 1);

    delete[] iw;
    delete[] w;
}

/*! 
  Old implementation of computing foot Jacobian.
 */
void Jacobian_old(StateVec &x, SpMat &J, SpMat &Jd)
{
    double **arg, **res, *w;
    int_T *iw;
    int_T sz_arg, sz_res, sz_iw, sz_w;
    size_t n_in, n_out, ou;

    n_in = Jacob_F_n_in();
    n_out = Jacob_F_n_out();
    Jacob_F_work(&sz_arg, &sz_res, &sz_iw, &sz_w);
    const casadi_int *ou_sp_info;
    const casadi_int **ou_index = new const casadi_int *[n_out];
    const casadi_int **ou_colptr_info = new const casadi_int *[n_out];
    const casadi_int **ou_row_info = new const casadi_int *[n_out];
    casadi_int *nnz_ou = new casadi_int[n_out]; // nnz of output variables

    arg = new double *[n_in];
    res = new double *[n_out];
    iw = new int_T[sz_iw];
    w = new double[sz_w];

    arg[0] = x.data();

    for (ou = 0; ou < n_out; ou++)
    {
        ou_sp_info = Jacob_F_sparsity_out(ou);
        ou_index[ou] = ou_sp_info;
        ou_colptr_info[ou] = ou_sp_info + 2;
        ou_row_info[ou] = ou_colptr_info[ou] + ou_index[ou][1] + 1;
        nnz_ou[ou] = *(ou_row_info[ou] - 1);

        res[ou] = new double[nnz_ou[ou]];
    }
    Jacob_F((const double **)arg, res, iw, w, 0);

    vector<T> *triplist = new vector<T>[n_out];

    size_t col, col_temp, row, i_nz, i_out;

    for (i_out = 0; i_out < n_out; i_out++)
    {
        i_nz = 0;
        for (col = 0; col < ou_index[i_out][1]; col++)
        {
            col_temp = col;
            while ((col_temp + 1 < ou_index[i_out][1]) && (ou_colptr_info[i_out][col_temp + 1] == 0))
            {
                col_temp = col_temp + 1;
            }

            for (row = 0; i_nz < ou_colptr_info[i_out][col_temp + 1]; ++i_nz, ++row)
            {
                triplist[i_out].push_back(T(ou_row_info[i_out][i_nz], col, res[i_out][ou_colptr_info[i_out][col] + row]));
            }
        }
    }
    J.setFromTriplets(triplist[0].begin(), triplist[0].end());
    Jd.setFromTriplets(triplist[1].begin(), triplist[1].end());
}

/*! 
  Old implementation of computing dynamics partial (slow).
 */
void dynamics_par_old(StateVec &x, ContrlVec &u, SpMat &fx, SpMat &fu, SpMat &gx, SpMat &gu)
{
    double **arg, **res, *w;
    int_T *iw;
    size_t n_in, n_out, ou;
    int_T sz_arg, sz_res, sz_iw, sz_w;

    n_in = Dyn_FL_par_n_in();
    n_out = Dyn_FL_par_n_out();
    Dyn_FL_par_work(&sz_arg, &sz_res, &sz_iw, &sz_w);

    const casadi_int *ou_sp_info;
    const casadi_int **ou_index = new const casadi_int *[n_out];
    const casadi_int **ou_colptr_info = new const casadi_int *[n_out];
    const casadi_int **ou_row_info = new const casadi_int *[n_out];
    casadi_int *nnz_ou = new casadi_int[n_out]; // nnz of output variables

    arg = new double *[n_in];
    res = new double *[n_out];
    iw = new int_T[sz_iw];
    w = new double[sz_w];
    arg[0] = x.data();
    arg[1] = u.data();

    // std::cout << "Number of output: " << n_out<<endl;
    // std::cout << "Number of input: " << n_in<<endl;

    for (ou = 0; ou < n_out; ou++)
    {
        ou_sp_info = Dyn_FL_par_sparsity_out(ou);
        ou_index[ou] = ou_sp_info;
        ou_colptr_info[ou] = ou_sp_info + 2;
        ou_row_info[ou] = ou_colptr_info[ou] + ou_index[ou][1] + 1;
        nnz_ou[ou] = *(ou_row_info[ou] - 1);

        res[ou] = new double[nnz_ou[ou]];
    }

    Dyn_FL_par((const double **)arg, res, iw, w, 0);

    vector<T> *triplist = new vector<T>[n_out];

    size_t col, col_temp, row, i_nz = 0, i_out;

    for (i_out = 0; i_out < n_out; i_out++)
    {
        i_nz = 0;
        for (col = 0; col < ou_index[i_out][1]; col++)
        {
            col_temp = col;
            while ((col_temp + 1 < ou_index[i_out][1]) && (ou_colptr_info[i_out][col_temp + 1] == 0))
            {
                col_temp = col_temp + 1;
            }

            for (row = 0; i_nz < ou_colptr_info[i_out][col_temp + 1]; ++i_nz, ++row)
            {
                triplist[i_out].push_back(T(ou_row_info[i_out][i_nz], col, res[i_out][ou_colptr_info[i_out][col] + row]));
            }
        }
    }

    fx.setFromTriplets(triplist[0].begin(), triplist[0].end());
    fu.setFromTriplets(triplist[1].begin(), triplist[1].end());
    gx.setFromTriplets(triplist[2].begin(), triplist[2].end());
    gu.setFromTriplets(triplist[3].begin(), triplist[3].end());

    for (ou = 0; ou < n_out; ou++)
    {
        delete[] res[ou];
    }
    delete[] res;
    delete[] arg;
    delete[] iw;
    delete[] w;
    delete[] nnz_ou;
    delete[] ou_index;
    delete[] ou_row_info;
    delete[] ou_colptr_info;
    delete[] triplist;
}
